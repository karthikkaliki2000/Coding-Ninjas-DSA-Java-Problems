package huffmancoding;

import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;

public class HuffmanCoding {
   
	 public static void printCode(HuffmanNode root, String s) 
	    { 
	  
	        // base case; if the left and right are null 
	        // then its a leaf node and we print 
	        // the code s generated by traversing the tree. 
	        if (root.left == null && root.right == null
	            && Character.isLetter(root.c)) { 
	  
	            // c is the character in the node 
	            System.out.println(root.c + ":" + s); 
	  
	            return; 
	        } 
	  
	        // if we go to left then add "0" to the code. 
	        // if we go to the right add"1" to the code. 
	  
	        // recursive calls for left and 
	        // right sub-tree of the generated tree. 
	        printCode(root.left, s + "0"); 
	        printCode(root.right, s + "1"); 
	    } 
    public static void main(String[] args) {
    	int n = 6; 
        char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; 
        int[] charfreq = { 5, 9, 12, 13, 16, 45 }; 
        PriorityQueue<HuffmanNode> q=new PriorityQueue<HuffmanNode>(n,new MyComparator());
        for(int i=0;i<n;i++) {
        	HuffmanNode hn=new HuffmanNode(charArray[i], charfreq[i]);
        	q.add(hn);
        	
        }
        
       // System.out.println(q.peek().data);
        HuffmanNode root=null;
        while(q.size()>1) {
        	HuffmanNode min1=q.peek();
        	q.poll();
        	HuffmanNode min2=q.peek();
        	q.poll();
        	HuffmanNode dupNode=new HuffmanNode('-',min1.data+min2.data);
        	dupNode.left=min1;
        	dupNode.right=min2;
        	root=dupNode;
        	q.add(dupNode);
        	
        }
        printCode(root,"");
	}
		   
}
class MyComparator implements Comparator<HuffmanNode> { 
    public int compare(HuffmanNode x, HuffmanNode y) 
    { 
  
        return x.data - y.data; 
    } 
} 
